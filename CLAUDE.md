# iDempiere Aesthetics UI (idempiere-module-ui)

## Project Overview

Vue 3 + TypeScript SPA for aesthetics clinic operations, deployed as an OSGi WAB bundle on iDempiere 12. All document forms are **metadata-driven** — field layouts come from iDempiere's Application Dictionary (AD_Field/AD_Column), not hardcoded HTML.

- **Stack**: Vue 3, Vite 7, TypeScript 5.9, PrimeVue 4 (Unstyled), Pinia 3, Vitest
- **Bundle**: `org.idempiere.ui.aesthetics` → `https://<host>:8443/aesthetics/#/`
- **Backend**: iDempiere REST API (OData-style queries)

## Commands

```bash
# Development
cd webapp && npm run dev          # Vite dev server (port 5173, proxies /api)
cd webapp && npm run test         # Run tests once (vitest run)
cd webapp && npm run test:watch   # Watch mode
cd webapp && npm run type-check   # vue-tsc --noEmit

# Build & Deploy
bash build.sh                     # Build Vue + create OSGi JAR
bash build.sh --deploy            # Build + deploy to Felix Web Console
```

## Project Structure

```
webapp/src/
├── api/              # REST API modules (one per domain)
│   ├── client.ts     # Axios instance + 401 interceptor
│   ├── metadata.ts   # AD_Field/AD_Column fetching, FK resolution, defaults
│   ├── lookup.ts     # Dynamic reference ID lookups (cached)
│   ├── order.ts      # C_Order + C_OrderLine
│   ├── payment.ts    # C_Payment
│   ├── inout.ts      # M_InOut + M_InOutLine
│   ├── production.ts # M_Production + M_ProductionLine
│   ├── request.ts    # R_Request (consultations)
│   ├── assignment.ts # S_ResourceAssignment (appointments)
│   ├── bpartner.ts   # C_BPartner + AD_User (contacts)
│   ├── resource.ts   # S_Resource (doctors)
│   ├── attachment.ts # AD_Attachment
│   ├── dictionary.ts # AD_Table/Column/Field browser
│   └── utils.ts      # OData escaping, date formatting
├── components/       # Reusable components
│   ├── DynamicForm.vue      # Renders field defs → mandatory/optional sections
│   ├── DynamicField.vue     # Single field by AD_Reference_ID type
│   ├── SearchSelector.vue   # FK picker (dropdown ≤50, search >50, QuickCreate)
│   ├── StatusBadge.vue      # DocStatus colored badge
│   ├── DocActionBar.vue     # Complete/Void/Cancel buttons
│   └── AppHeader.vue        # Navigation + user menu
├── composables/
│   ├── useDocumentForm.ts   # Core: load metadata → init defaults → validate → payload
│   ├── useMetadata.ts       # Metadata caching per tabId
│   ├── useDocAction.ts      # Document workflow (Complete via Process endpoint)
│   ├── useAttachment.ts     # File upload/download
│   └── usePermission.ts     # AD_SysConfig role-based page access
├── stores/
│   └── auth.ts              # Multi-step login, token/context persistence
├── router/
│   └── index.ts             # Hash-based routing, auth guards, permission checks
├── i18n/
│   └── fieldLabels.ts       # Chinese column→label mappings (150+ entries)
└── views/                   # Page components (list + form per domain)
    ├── consultation/        # R_Request (Tab 344)
    ├── order/               # C_Order (Tab 186) + lines (Tab 187)
    ├── treatment/           # M_Production (Tab 319) + lines (Tab 321)
    ├── payment/             # C_Payment (Tab 330)
    ├── shipment/            # M_InOut (Tab 257) + lines (Tab 258)
    ├── customer/            # C_BPartner (Tab 220) + AD_User contacts
    ├── appointment/         # S_ResourceAssignment (Tab 415) + CalendarView
    └── admin/               # FieldConfig, TableList, ColumnList, ReferenceData

osgi-bundle/
├── META-INF/MANIFEST.MF    # OSGi metadata (DO NOT modify without understanding)
├── WEB-INF/web.xml          # Servlet config
└── web/                     # Built assets (git-ignored, generated by vite build)
```

## Architecture: Metadata-Driven Forms

All document forms follow this pattern:

```typescript
const { visibleFieldDefs, formData, isCreate, readOnly, load, getFormPayload } = useDocumentForm({
  tabId: 186,        // AD_Tab_ID — determines which fields to load
  recordId: computed(() => route.params.id ? Number(route.params.id) : null),
  loadRecord: (id) => getOrder(id),
  columnFilters: { C_BPartner_ID: 'IsCustomer eq true' },
})
```

**Flow**: `useDocumentForm` → `fetchFieldDefinitions(tabId)` → AD_Field + AD_Column batch query → resolve FK table names → `DynamicForm` renders fields → `DynamicField` picks widget by `AD_Reference_ID`.

### AD_Tab_ID Mapping

| Module | Table | Tab ID | Line Tab |
|--------|-------|--------|----------|
| Order | C_Order | 186 | 187 |
| Shipment | M_InOut | 257 | 258 |
| Production | M_Production | 319 | 321 |
| Payment | C_Payment | 330 | — |
| Consultation | R_Request | 344 | — |
| Appointment | S_ResourceAssignment | 415 | — |
| Customer | C_BPartner | 220 | — |

### AD_Reference_ID → Widget Mapping

| Ref ID | Type | Widget |
|--------|------|--------|
| 10 | String | `<input type="text">` |
| 11 | Integer | `<input type="number">` |
| 12 | Amount | `<input type="number" step="0.01">` |
| 14 | Text | `<textarea>` |
| 15 | Date | `<input type="date">` |
| 16 | DateTime | `<input type="datetime-local">` |
| 17 | List | `<select>` (from AD_Ref_List) |
| 18 | Table | `SearchSelector` (table from AD_Ref_Table) |
| 19 | TableDirect | `SearchSelector` (table from column name) |
| 20 | YesNo | `<input type="checkbox">` |
| 29 | Quantity | `<input type="number">` |
| 30 | Search | `SearchSelector` (table from AD_Ref_Table or column name) |
| 38 | Memo | `<textarea>` |
| 13 | ID | Hidden |
| 28 | Button | Hidden |

## Critical Patterns

### FK Table Name Resolution (Ref 18/19/30)

Many iDempiere columns (C_BPartner_ID, C_Order_ID, M_Product_ID) are Ref 30 (Search) **without** `AD_Reference_Value_ID`. The table name is derived from the column name by stripping `_ID`:

- **Ref 19** (TableDirect): Always derive from column name (`M_Warehouse_ID` → `M_Warehouse`)
- **Ref 18/30** with `AD_Reference_Value_ID`: Resolve via `AD_Ref_Table` → `AD_Table`
- **Ref 18/30** without `AD_Reference_Value_ID`: Fallback to column name derivation

This fallback exists in both `metadata.ts` (during fetch) and `DynamicField.vue` (safety net).

### iDempiere REST API Conventions

- List/FK fields return **objects**: `{"id": "DR", "identifier": "Drafted"}` — always extract `.id`
- DateTime format: `yyyy-MM-dd'T'HH:mm:ssZ` — NO milliseconds (use `toIdempiereDateTime()`)
- DocAction must go through Process endpoint, not field update
- PUT `/auth/tokens` returns a **new token** — old token immediately invalid
- OData queries: `$filter`, `$select`, `$orderby`, `$top`, `$expand`, `$count`

### Authentication Flow

Multi-step cascading: `POST tokens` → `GET roles` → `GET orgs` → `GET warehouses` → `PUT tokens`

Token + context + user all persisted to localStorage. If token exists but context is missing on init, force re-login.

### Dynamic Lookups

Never hardcode reference IDs (C_DocType_ID, C_BP_Group_ID, etc.). Use `api/lookup.ts` which caches in-memory and clears on logout.

### SearchSelector Modes

- **Dropdown** (≤50 records): Load all options, render `<select>`
- **Search** (>50 records): Debounced search input with autocomplete
- **resolveCurrentLabel()**: When editing, resolves numeric ID to display name via single GET

## Testing

```bash
cd webapp && npm run test    # 87+ tests across 22 files
```

- **Framework**: Vitest + happy-dom + Vue Test Utils
- **Mocking**: Mock `apiClient` (from `@/api/client`), `useAuthStore`, `useRouter`
- **Async**: Use `flushPromises()` for async operations, `setTimeout` + `$nextTick` for SearchSelector init
- Tests in `__tests__/` directories next to source files

## Deployment

The app is packaged as an OSGi WAB JAR and deployed to iDempiere's Felix container:

1. `bash build.sh --deploy` builds Vue → creates JAR → copies to `plugins/` → auto-updates via Felix Web Console
2. Felix Web Console at `/osgi/system/console/bundles` (login: SuperUser/System)
3. Bundle update uses `action=install` + `uploadid={bundleId}` to keep the same bundle ID

**MANIFEST.MF is sacred** — don't modify without understanding OSGi implications.

## TypeScript Notes

- `erasableSyntaxOnly: true` — `public x` in constructor params is NOT allowed; declare field separately
- Path alias: `@/` → `src/`
- Vue files need `<script setup lang="ts">`

## Language

- UI labels are in **Traditional Chinese** (zh-TW)
- Field labels from `i18n/fieldLabels.ts` override English AD_Field.Name
- Code comments and variable names in English
